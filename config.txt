Конкретный синтаксис для языка L:

Пробельные символы (кроме переводов строк) разрешены в любых количествах между операторами / ключевыми словами / идентификаторами

Функция задаётся следущим образом:

"begin function <name> n type arg_1 type arg_2 \dotso type arg_n 
body
end function", где 
name --- имя функции (строка)
n --- 10-чное число (количество аргументов, которая принимает функция)
type -> int2 | int10 | string
arg_i --- собственно сами аргументы
body -> "begin body\n" + последовательность операторов + "end body\n"

Имена функций должны быть уникальны и не совпадать с ключевыми словами или идентификаторами. 
Одна из функций обязательно задаётся так: "function main 00" --- точка входа в программу.

Литерал -> Число | Строка
Число -> 10-чное | 2-чное
10-чное -> 0([1-9][0-9]* | 0)
2-чное ->  1(1[0-1]* | 0)
Строка -> "символ*"
Символ -> a | b | \dotso | z

Оператор -> skip | only_if | if | while | связывание | присвоение | вызов функции

последовательность операторов -> (последовательность операторов "\n" | \eps) оператор

skip -> "skip"
only_if -> "begin only_if\n" expression "\n" body "end only_if\n"
if -> "begin if\n" expression "\n" body "else\n" body "end if\n"
while -> "begin while\n" expression "\n" body "end while\n"
связывание -> "var " (int2 name = "\n" expression "\n" | int10 name = "\n" expression "\n" | string name = "\n" expression "\n")
присвоение -> "change " name =  "\n" expression "\n" 
вызов функции -> "call " name n arg_1 arg_2 \dotso arg_n

Выражение (expression) обязано находиться на отдельной строке
expression -> литерал | переменная | вызов функции | логическое выражение bool_op логическое выражение
логическое выражение -> арифметическое выражение sign арифметическое выражение
bool_op -> || или &&
арифметическое выражение -> подвыражение sign подвыражение
sign -> == | /= | <= | < | >= | >
подвыражение -> mult + mult | mult - mult
mult -> pow * pow | pow / pow
pow -> выражение ^ выражение

Переменная -> name такое, что раньше было связывание с ним	
